---
theme: gaia
paginate: true
backgroundColor: #fff
footer: Лекция №7: Современный Backend / Курс Web-программирования 2021 / ПГНИУ
style: |
    section {
      font-family: "Open Sans", "Tahoma", "apple color emoji", "segoe ui emoji", "segoe ui symbol", "noto color emoji";
      font-size: 32px;
      letter-spacing: unset;
    }
    header,
    footer {
      font-size: 50%;
    }
    section::after {
      content: attr(data-marpit-pagination) ' / ' attr(data-marpit-pagination-total);
    }
---

<!-- _class: lead -->

# **Лекция №7: Современный Backend**

Web-программирование / ПГНИУ

---

![bg w:50%](img/07-Modern-Backend-Regular.png)

---

![bg w:80%](img/07-Modern-Backend-Regular2.png)

---

# Простейшая инфраструктура

- Есть веб-приложение (клиент-серверное приложение?)
- Это приложение на сервере
  - напрямую принимающее запросы
  - отдающее HTML страницы веб-сайта
- Страницы отображаются у пользователя в веб-браузере (возможно, с использованием JavaScript)

---

# Проблемы

- Как запустить несколько приложений на одном сервере? Ведь всем нужен 80/443 порт по дефолту
- Как подключать несколько доменных имён к серверу
- Нужно самостоятельно реализовывать стандартные задачи
  - HTTPS
  - Эффективно отдавать файлы
  - Реализовывать кэширование
    
---

# Веб-сервер

- HTTP-сервер
- Маршрутизация
- Хостинг статики (html, js, css, и т.п. файлов)
- Обратный прокси (reverse proxy) к другим приложениям
- Балансировка нагрузки
- HTTPS, HTTP/2
- Кэширование, сжатие
- Ограничение нагрузки (трафик, запросы в секунду)
- Nginx, Apache, IIS, Traefik, Caddy

---

![bg w:80%](img/07-Modern-Backend-WebServer.png)

---

# CDN

- Проблема - чем дальше клиент от сервера, тем больше времени идёт запрос (количество посредников в сети + ограничения скорости света)
- Статичные файлы - статичны. Их не требуется часто изменять или синхронизировать.
- Решение - **Content Delivery Network** (система доставки контента)
- Географически распределённая система прокси-серверов и статических серверов
- Клиент получает содержимое с ближайшего
- Стили, скрипты, картинки и прочие ресурсы

---

![bg w:80%](img/07-Modern-Backend-CDN.png)

---

![bg w:80%](img/07-Modern-Backend-CDN2.png)

---

![bg w:95%](img/07-Modern-Backend-CDN3.png)

---

# Масштабирование

- **Вертикальное масштабирование** - увеличение вычислительных ресурсов
- **Горизонтальное масштабирование** - увеличение вычислительных узлов
- Запрос-за-процесс, запрос-на-поток, запрос-на-асинхронное-приложение
- Количество процессов на одном сервере - ограничено
- Решение - несколько серверов + балансировщик нагрузки

---

# Балансировщик нагрузки

- Распределяет запросы между несколькими экземплярами приложения (возможно, на нескольких серверах) 
- Round-robin - просто по очереди
- Random - случайно
- Умно, с учётом загрузки
- Веб-сервера, специальные системы

---

![bg w:80%](img/07-Modern-Backend-LoadBalancer.png)

---

# Message Broker

- Нескольким экземплярам приложения (или разным сервисам) нужно связываться, уведомлять друг друга о событиях
- **Брокер сообщений** — промежуточное ПО, обеспечивающее связь между приложениями
- Apache Kafka, RabbitMQ

---

![bg w:80%](img/07-Modern-Backend-Broker.png)

---

# Распределённое приложение

- Большое монолитное приложение может быть сложно разрабатывать и сложно масштабировать
- Возможно, большая нагрузка идёт лишь на некоторую часть приложения
- Возможно, есть отдельные тяжёлые операции, которые можно выполнять не сразу
- Решение - распределённое приложение, **сервис-ориентированная архитектура**
- Сервисы могут общаться не только по HTTP
- Сервисы можно масштабировать независимо

---

![bg w:80%](img/07-Modern-Backend-SOA.png)

---

# Message Queue

- Некоторые задачи не нужно выполнять сразу
  - задачи по расписанию
  - тяжелые, долгие задачи
- Можно выполнять такие задачи в отдельном сервисе (сервисах), складывая их в очередь
- Здесь помогут **Очереди Сообщений**
- Например, RabbitMQ или разные реализации протокола AMQP

---

![bg w:80%](img/07-Modern-Backend-MQ.png)

---

# Микросервисы

- Вместо одного распределённого приложения можно иметь много маленьких независимых микросервисов
- Каждый микросервис максимально самодостаточный в решении задач, и имеет свои сервисы (БД и тд)
- Микросервисы могут переиспользоваться разными приложениями

---

![bg w:80%](img/07-Modern-Backend-MS.png)

---

# Цена сервис-ориентированной и микросервисной архитектур

- Сложное развёртывание
- Сложное логирование (запрос проходит через множество сервисов)
- Сложная отладка
- Сложная разработка (каждый (микро) сервис требуется проектировать, продумывать транспорт)

---

# Хранение данных

* Основное хранилище - БД на Сервере СУБД (реляционное, документ-ориентированное и т.д.)
* Проблемы:
    * Часто забираются одни и те же данные
    * Медленный полнотекстовый поиск
    * Есть неизменяемые данные, которые просто накапливаются, но их требуется обрабатывать
    * Сложно масштабировать (распределённая РСУБД - БОЛЬ)
* Решение - больше баз данных на разных СУБД

---

# Кэширование данных

- Простые key-value БД, работающие в in memory
- Redis, Memcached
- Используются для кэширования данных и "общей памяти" разных сервисов

---

# Сервер полнотекстового поиска

- БД, хранящая проиндексированные данные (например, словарь по словам) для быстрого текстового поиска
- Elasticsearch

---

# Много-много данных

- Кроме основных изменяемых данных, есть данные, которые только добавляются, но приходят большим потоком и требуют обработки
- Логирование приложения 
- Логирование действий пользователя
- Задачи:
    - Real-time аналитика и простой мониторинг
    - BigData, сложная аналитика и машинное обучение
    - Хранение исторических данных

---

# Хранилище данных

Хранилище данных (warehouse) - система хранение больших объёмов неизменяемых данных

---

# Базы данных временных рядов

- Time series database (TSDB)
- БД, где эффективно хранятся последовательности данных, привязанных к временной метке
- Оптимизированы на быстрый приём данных, независимо от общего объёма
- Автоматическое удаление старых данных
- Далее данные уходят потребителю (Grafana, Datadog...)
- Логи, данные для аналитики
- Prometheus, InfluxDB 

---

# Потоковая обработка данных

- Потоковая обработка данных, анализ данных
- Распределённое хранение большого объёма данных для этой обработки
- Hadoop, Apache Spark

---

# Пользовательские файлы

- Хранить файлы в ФС сервера - плохо
- Simple Storage Service (s3) - файловый хостинг
- Служба, предоставляющая возможность хранения и получения данных (файлов)
- Изначально сервис в Amazon AWS (AWS s3), далее протокол, реализованный многими сервисами
- Google Cloud s3, Azure s3
- self-hosted - minio

---

![bg w:95%](img/07-Modern-Backend-Infrastructure.png)

---

<!-- _class: lead -->

# **Аутентификация 2**

---

# Аутентификация

* **HTTP Basic Auth**: браузер сам делает форму, хранит данные и отправляет их в заголовке
* **Session**: данные аутентификации и другие данные хранятся в сессии
    - **client-side session** - зашифровано в cookie (не безопасно)
    - **server-side session** - данные на сервере в хранилище, а в cookie только SID
* **Аутентификация по токенам** - токен аутентификации выдаётся сервисом аутентификации и любым способом передаётся с запросом

---

# Проблемы с аутентификацией

* Проблема 1: требуется сохранять аутентификацию для разных сервисов на разных доменах
* Проблема 2: stateful аутентификация - это затраты. Требуется из каждого сервиса либо всегда обращаться в сервис аутентификации, либо иметь доступ к хранилищу (сессиям)

---

# Проблема с кросс-доменными запросами

* Cookie отправляются на тот домен, с которого они были установлены
* Значит информацию об аутентификации надо отправлять не в Cookie, а как-то в запросе из клиента
* Заголовок `Authorization`

---

# Stateless авторизация

- Вместо идентификатора сессии используем самодостаточный токен с подписью (или зашифрованный)
- В токене сохраняем данные авторизации
- Сервисы могут верить токену, потому что он подписан
- Подпись - просто хэш, симметричное шифрование, асимметричное шифрование  

---

![bg w:80%](img/07-Modern-Backend-token-auth.png)

---

# JWT

* **JSON Web Token** - компактное, безопасное для URL средство представления заявок, передаваемых между двумя сторонами (RFC 7519)
* Строка в формате `header.payload.signature`
  `Header` – Информация об алгоритме вычисления подписи
   `header = { "alg": "RS256", "typ": "JWT"}`
  `Payload` – собственно полезная нагрузка
  `payload = { "userId": "1", "name": "Petya", "isAdmin": true }`
  `Signature` – цифровая подпись
* `JWT = base64(header) + '.' base64(payload) + '.' + base64(signature)`

---

![bg contain](img/jwt.png)

---

# JWT для аутентификации

* JWT - подписанные данные. Мы знаем, что данные там достоверны и можем ему верить
* Можно делать **Stateless** аутентификации
* Проблема - инвалидация...
    - Инвалидация по истечении времени
    - Инвалидация в случае, если токен скомпрометирован

---

# JWT с ограниченным временем жизни

Первая часть решения простая - ограничивать время жизни JWT, передавая в нём метку времени, когда он истечёт.

---

# Refreshing an Expired Access Token Flow

* Единственный надёжный способ инвалидировать токен - иметь базу инвалидированных токенов. Это делает использование JWT (stateless) бесполезным.
* Сделаем токен **короткоживущим** (~1-5 минут)
* Чтобы пользователя не разлогинило, добавим ещё один токен - одноразовый долгоживущий **refresh_token**, который используется для получения нового JWT

---

# JWT + refresh_token

- JWT (access_token):
     - Stateless, подписанный
     - Короткоживущий (~1-5 мин.)
     - Используется для авторизации в сервисах приложения
- refresh_token (любой токен, например, UUID):
    - Statefull
    - Живёт долго, одноразовый
    - Используется для получения новой пары JWT + refresh_token на сервисе аутентификации

---

![bg contain](img/07-Modern-Backend-jwt-login.png)

---

![bg](#000)
![bg contain](img/5-minutes-later.jpg)

---

![bg contain](img/07-Modern-Backend-jwt-refresh.png)

---

# Как защититься от кражи токенов

* Использовать HTTPS (обязательно!)
* Хранить в токене идентификатор устройства (fingerprint)
* Основная потенциальная причина кражи - XSS
* **refresh token** можно хранить в `httpOnly` `Cookie`
* **access token** хранить как можно безопаснее
    - LocalStorage или простой Cookie - самое не безопасное
    - В локальной переменной - лучше
    - Worker - интереснее + общее обновление
 
---

# Когда использовать

- Требуется stateless авторизация:
    - Микросервисная архитектура без единого gateway
    - Большая нагрузка, при которой лишний запрос в сервис аутентификации или хранилище сессий - это дорого 
- Нет возможности использовать Cookie (вытекает из stateless авторизации)

---

# OAuth

- OAuth 1.0 и OAuth 2.0 - протоколы аутентификации в сторонних (third-party) приложениях
- Описывают разные схемы аутентификации в сторонних приложениях
- Аутентификация через социальные сети
- Аутентификация приложения для использования API других приложений

---

# Ссылки

- Эффективные надежные микросервисы: [https://habr.com/ru/company/odnoklassniki/blog/499316/](https://habr.com/ru/company/odnoklassniki/blog/499316/)
- HolyJS 2018 Moscow | Дмитрий Пацура — Микросервисная архитектура: [https://www.youtube.com/watch?v=wXaoKroEnp4](https://www.youtube.com/watch?v=wXaoKroEnp4)
- IBM | SOA vs. Microservices: What’s the Difference?: [https://www.ibm.com/cloud/blog/soa-vs-microservices](https://www.ibm.com/cloud/blog/soa-vs-microservices) 
- Wikipedia OAuth: [https://ru.wikipedia.org/wiki/OAuth](https://ru.wikipedia.org/wiki/OAuth)
- JWT: [https://jwt.io](https://jwt.io)
- Хорошая статья про JWT: [https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/](https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/)
